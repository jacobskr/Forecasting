---
title: "Untitled"
author: "Kyle Jacobs"
date: "November 19, 2018"
output:
  ioslides_presentation:
    css: myCss4.css
runtime: shiny
---

```{r message=FALSE, warning=FALSE, include=FALSE}
require(data.table)
require(TSA)
require(forecast)
require(xts)
require(fpp2)
require(ggplot2)
require(tidyverse)
require(dplyr)
require(nnfor)
require(opera)

#https://www.eia.gov/dnav/pet/hist/LeafHandler.ashx?n=PET&s=wgfupus2&f=W
dta <- read.csv("C:/Users/ejvpaba/Desktop/Python/Forecasting/US_OIL.csv")
dta2 <- tail(dta, 260)[,2]

#seasons data
seasons <- read.csv("C:/Users/ejvpaba/Desktop/Python/Forecasting/seasons.csv")
seasons <- tail(seasons, 260)
seasons <- seasons[,c(2,3,4)]
seasons.tr <- seasons[1:208,]
seasons.val <- seasons[209:260,]

# True frequency training/validation sets
oil_freq <- ts(dta2, frequency = 365.25/7, start=2014-(46/365.25))
oil_freq.tr <- ts(oil_freq[1:208], freq=365.25/7, start=2014-(46/365.25))
oil_freq.val <- ts(oil_freq[(length(oil_freq)-51):length(oil_freq)],
                   freq=365.25/7, 
                   start=end(oil_freq.tr)+(7/365.25))

#Rounded frequency training/validation sets
oil_round <- ts(dta2, freq=52, start = c(2013, 46))
oil_round.tr <- ts(oil_freq[1:208], freq=52, start=c(2013, 46))
oil_round.val <- ts(oil_freq[209:260], freq=52, start=c(2017, 46))

#naive model
fc_naive <- naive(oil_freq.tr, h = 52)
Naive <- fc_naive

#ETS Model
fit_ets <- ets(oil_freq.tr)
fc_ets <- forecast(fit_ets, h=52)
ETS <- fc_ets

#stlm Model
fit_stlm <- stlm(oil_freq.tr)
fc_stlm <- forecast(fit_stlm, h=52)
STLM <- fc_stlm

#Base Arima Model
fit_base <- auto.arima(oil_round.tr, stepwise=T)
fc_base <- forecast(fit_base, h = 52)
Base_Arima <- fc_base

#Using period set in ts, find # fourier regressors to use to minimize AIC
bestfit <- list(aicc=Inf)
for(i in 1:25)
{
  z <- fourier(oil_freq.tr, K=i)
  fit <- auto.arima(oil_freq.tr, xreg=fourier(oil_freq.tr, K=i), seasonal=FALSE)
  if(fit$aicc < bestfit$aicc)
    bestfit <- list(aicc=fit$aicc, k=i, fit=fit)
  else break;
}
fc_freg <- forecast(bestfit$fit, xreg=fourier(oil_freq.tr, K=bestfit$k, h=52))
Fourier_Reg <- fc_freg

#Try finding potential multi-seasonality. Use periodogram to find
#frequencies wih the highest spectral power densities
bestfit1 <- list(aicc=Inf)
for(i in 1:3) { 
  for (j in 1:2){ 
    for (p in 1:3){ #i,j, and p need to be < freq/2
      try({
      z1 <- fourier(ts(oil_freq.tr, frequency=54), K=i)
      z2 <- fourier(ts(oil_freq.tr, frequency=72), K=j)
      z3 <- fourier(ts(oil_freq.tr, frequency=30.85714286), K=p)
      fit <- auto.arima(oil_freq.tr, xreg=cbind(z1, z2, z3), seasonal=F, stepwise = T)
      print(cbind(i,j,p))
      })
      if(fit$aicc < bestfit1$aicc) {
        bestfit1 <- list(aicc=fit$aicc, i=i, j=j, p=p, fit=fit)
      }
    }
  }
}
#(3,1,3) was the best
fc_fper <- forecast(bestfit1$fit, 
                       xreg=cbind(
                         fourier(ts(oil_freq.tr, frequency=54),
                                 K=bestfit1$i, h=length(oil_freq.val)),
                         fourier(ts(oil_freq.tr, frequency=72), K=bestfit1$j,
                                 h=length(oil_freq.val)),
                         fourier(ts(oil_freq.tr, frequency=30.85714286),
                                 K=bestfit1$p, h=length(oil_freq.val))))
Fourier_Period <- fc_fper

# We can check if a seasons regressor will make forecast better
covariates <- c("winter", "spring", "summer")
fit_seasons <- auto.arima(oil_freq.tr, xreg = seasons.tr)
fc_seasons <- forecast(fit_seasons, xreg = seasons.val, h=52)
Base_Arima_Sns <- fc_seasons

#Can we do fourier with other external regressors?
bestfit2 <- list(aicc=Inf)
for(i in 1:25)
{
  x1 <- fourier(oil_freq.tr, K=i)
  x2 <- seasons.tr
  fit <- auto.arima(oil_freq.tr, xreg=cbind(x1, x2), seasonal=F)
  if(fit$aicc < bestfit2$aicc)
    bestfit2 <- list(aicc=fit$aicc, k=i, fit=fit)
  else break;
}
fc_comb <- forecast(bestfit2$fit, xreg=cbind(fourier(oil_freq.tr, K=bestfit2$k, h=52), seasons.val))
Fourier_Reg_Sns <- fc_comb

#Multiseasonal dataset
wkly <- 365.25 / 7
mthly <- wkly / 12
qtrly <- wkly / 4
oil_msts <- data.frame(dta2)
oil_msts[,c(2,3,4)] <- seasons
oil_msts <- msts(oil_msts, seasonal.periods=c(wkly, mthly, qtrly),
                 ts.frequency = wkly, start=2014-(46/365.25))
oil_msts.tr <-msts(oil_msts[1:208,], seasonal.periods=c(wkly, mthly, qtrly), 
                   ts.frequency = wkly, start=2014-(46/365.25))
oil_msts.val <- msts(oil_msts[(length(oil_freq)-51):length(oil_freq),],
                    seasonal.periods=c(wkly, mthly, qtrly),
                    ts.frequency = wkly,
                    start=end(oil_msts.tr)+(7/365.25))
colnames <- c("barrels", "winter", "spring", "summer")
colnames(oil_msts.tr) <- colnames
colnames(oil_msts.val) <- colnames
colnames(oil_msts) <- colnames

#tbats using msts
fit_tbats.msts <- tbats(oil_msts.tr[, "barrels"], seasonal.periods=c(wkly, mthly, qtrly))
fc_tbats.msts <- forecast(fit_tbats.msts, h=52)
MSTS_TBATS <- fc_tbats.msts

#Try to use covariates with msts
fit_arima.msts <- auto.arima(oil_msts.tr[, "barrels"], xreg=oil_msts.tr[, c(2,3,4)])
fc_arima.msts <- forecast(fit_arima.msts, xreg=oil_msts.val[, c(2,3,4)], h=52)
MSTS_Sns <- fc_arima.msts

#Maybe a neural network will be nice
  #no xregs
fit_nn <- nnetar(oil_freq.tr, lambda = 0.5)
autoplot(forecast(fit_nn, h=52))
fc_nn <- forecast(fit_nn, PI=T, h=52)
NN <- fc_nn

  #xregs
fit_nn.xregs <- nnetar(oil_freq.tr, xreg = seasons.tr, lambda = 0.5)
fc_nn.xregs <- forecast(fit_nn.xregs, xreg = seasons.val, PI=T, h=52)
NN_Sns <- fc_nn.xregs

#Combine Models
comb_msts <- (fc_arima.msts[["mean"]] + fc_tbats.msts[["mean"]])/2
Com_MSTS <- comb_msts
comb_fourier <- (fc_comb[["mean"]] + fc_freg[["mean"]] +
                   fc_fper[["mean"]])/3
Com_Fourier <- comb_fourier
comb_season <- (fc_seasons[["mean"]] + fc_freg[["mean"]] +
                  + fc_nn.xregs[["mean"]] + fc_comb[["mean"]])/4
Com_Sns <- comb_season
comb_nn <- (fc_nn[["mean"]] + fc_nn.xregs[["mean"]])/2
Com_NN <- comb_nn

#Find best combo
names <- c('fc_naive', 'fc_ets', 'fc_stlm', 'fc_base', 
           'fc_freg', 'fc_fper', 'fc_seasons', 'fc_comb', 
           'fc_arima.msts', 'fc_tbats.msts', 'fc_nn', 'fc_nn.xregs')
model_list <- list(fc_naive[["mean"]], fc_ets[["mean"]], fc_stlm[["mean"]],
                   fc_base[["mean"]], fc_freg[["mean"]], fc_fper[["mean"]], 
                   fc_seasons[["mean"]], fc_comb[["mean"]], fc_arima.msts[["mean"]],
                   fc_tbats.msts[["mean"]], fc_nn[["mean"]], fc_nn.xregs[["mean"]])

bestRMSE <- Inf
for (i in 2:length(model_list)) {
  cmb = combn(model_list, m=i)
  for (c in 1:ncol(cmb)) {
    cmbdf <- data.frame(cmb[,c])
    avg <- rowSums(cmbdf)/i
    ac <- accuracy(avg, oil_freq.val)["Test set","RMSE"]
    if (ac < bestRMSE) {
      bestRMSE <- ac
      bestmodel <- list(RMSE=bestRMSE, i=i, c=c, means=avg)
    }
  }
}
combn(names, bestmodel$i)[,bestmodel$c]

comb_best <- ts(bestmodel$means, frequency = 365.25/7, start = start(oil_freq.val))
Com_Best <- comb_best
decom_oil <- decompose(oil_round)
```

## Forecast Models

```{r ModelsShiny, echo=FALSE, eval=FALSE}
shinyApp(
ui <- fluidPage(
  (titlePanel("Forecast Models")),
  sidebarLayout(position = "left",
                sidebarPanel("Selection", 
                             width = 2,
                             selectInput(inputId = "FC_Model", 
                                         label = "Model",
                                         choices = c("Naive", "ETS", "STLM", "Base_Arima",
                                                     "Base_Arima_Sns", "Fourier_Reg",
                                                     "Fourier_Reg_Sns", "Fourier_Period",
                                                     "TBATS", "MSTS_Sns", "NN", "NN_Sns",
                                                     "Com_MSTS", "Com_Fourier", "Com_Sns",
                                                     "Com_NN", "Com_Best")),
                checkboxInput(inputId = "val",
                              label = "Show Validation Data",
                              value = FALSE)),
                mainPanel(
                  tabsetPanel(type = 'tabs',
                              tabPanel("Decomposition",
                                       plotOutput("decom", height = '800px')),
                              tabPanel("Forecasts",
                                       fluidRow(
                                         column(12, plotlyOutput("fcmodel")),
                                         column(12, plotOutput("residuals")))),
                              tabPanel("Math")

                                       )
                          )
                )
  ),

server = function(input, output) 
{
  output$fcmodel =   renderPlotly({
    if (input$FC_Model == "Naive"){
      if (input$val) {
        naivegg <- ggplot() +
                   autolayer(Naive$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(naivegg)
      }
      else {
        ggplotly(autoplot(Naive))
      }
    }
    else if (input$FC_Model == "ETS"){
      if (input$val) {
        etsgg <- ggplot() +
                   autolayer(ETS$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(etsgg)
      }
      else {
        ggplotly(autoplot(ETS))
      }
    }
    else if (input$FC_Model == "STLM"){
      if (input$val) {
        stlmgg <- ggplot() +
                   autolayer(STLM$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(stlmgg)
      }
      else {
        ggplotly(autoplot(STLM)) 
      }
    }
    else if (input$FC_Model == "Base_Arima"){
      if (input$val) {
        bagg <- ggplot() +
                   autolayer(Base_Arima$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(bagg)
      }
      else {
        ggplotly(autoplot(Base_Arima)) 
      }
    }
    else if (input$FC_Model == "Base_Arima_Sns"){
      if (input$val) {
        basgg <- ggplot() +
                   autolayer(Base_Arima_Sns$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(basgg)
      }
      else {
        ggplotly(autoplot(Base_Arima_Sns)) 
      }
    }
    else if (input$FC_Model == "Fourier_Reg"){
      if (input$val) {
        frgg <- ggplot() +
                   autolayer(Fourier_Reg$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(frgg)
      }
      else {
        ggplotly(autoplot(Fourier_Reg)) 
      }
    }
    else if (input$FC_Model == "Fourier_Reg_Sns"){
      if (input$val) {
        frsgg <- ggplot() +
                   autolayer(Fourier_Reg_Sns$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(frsgg)
      }
      else {
        ggplotly(autoplot(Fourier_Reg_Sns)) 
      }
    }
    else if (input$FC_Model == "Fourier_Period"){
      if (input$val) {
        fpgg <- ggplot() +
                   autolayer(Fourier_Period$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(fpgg)
      }
      else {
        ggplotly(autoplot(Fourier_Period)) 
      }
    }
    else if (input$FC_Model == "TBATS"){
      if (input$val) {
        tbatsgg <- ggplot() +
                   autolayer(MSTS_TBATS$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(tbatsgg)
      }
      else {
        ggplotly(autoplot(MSTS_TBATS)) 
      }
    }
    else if (input$FC_Model == "MSTS_Sns"){
      if (input$val) {
        mstssgg <- ggplot() +
                   autolayer(MSTS_Sns$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(mstssgg)
      }
      else {
        ggplotly(autoplot(MSTS_Sns)) 
      }
    }
    else if (input$FC_Model == "NN"){
      if (input$val) {
        nngg <- ggplot() +
                   autolayer(NN$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(nngg)
      }
      else {
        ggplotly(autoplot(NN)) 
      }
    }
    else if (input$FC_Model == "NN_Sns"){
      if (input$val) {
        nnsgg <- ggplot() +
                   autolayer(NN_Sns$mean, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(nnsgg)
      }
      else {
        ggplotly(autoplot(NN_Sns)) 
      }
    }
    else if (input$FC_Model == "Com_MSTS"){
      if (input$val) {
        cmstsgg <- ggplot() +
                   autolayer(Com_MSTS, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(cmstsgg)
      }
      else {
        ggplotly(autoplot(oil_freq.tr) + autolayer(Com_MSTS)) 
      }
    }
    else if (input$FC_Model == "Com_Fourier"){
      if (input$val) {
        cfgg <- ggplot() +
                   autolayer(Com_Fourier, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(cfgg)
      }
      else {
        ggplotly(autoplot(oil_freq.tr) + autolayer(Com_Fourier)) 
      }
    }
    else if (input$FC_Model == "Com_Sns"){
      if (input$val) {
        csgg <- ggplot() +
                   autolayer(Com_Sns, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(csgg)
      }
      else {
        ggplotly(autoplot(oil_freq.tr) + autolayer(Com_Sns)) 
      }
    }
    else if (input$FC_Model == "Com_NN"){
      if (input$val) {
        cnngg <- ggplot() +
                   autolayer(Com_NN, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(cnngg)
      }
      else {
        ggplotly(autoplot(oil_freq.tr) + autolayer(Com_NN)) 
      }
    }
    else if (input$FC_Model == "Com_Best"){
      if (input$val) {
        cbestgg <- ggplot() +
                   autolayer(Com_Best, series = 'Forecast') +
                   autolayer(oil_freq.val, series = 'Validation Data')
        ggplotly(cbestgg)
      }
      else {
        ggplotly(autoplot(oil_freq.tr) + autolayer(Com_Best)) 
      }
    }
  })
  output$residuals = renderPlot({
    if (input$FC_Model == "Naive") {
      checkresiduals(Naive, test=F)
    }
    else if (input$FC_Model == "ETS") {
      checkresiduals(ETS, test=F)
    }
    else if (input$FC_Model == "STLM") {
      checkresiduals(STLM, test=F)
    }
    else if (input$FC_Model == "Base_Arima") {
      checkresiduals(Base_Arima, test=F)
    }
    else if (input$FC_Model == "Base_Arima_Sns") {
      checkresiduals(Base_Arima_Sns, test=F)
    }
    else if (input$FC_Model == "Fourier_Reg") {
      checkresiduals(Fourier_Reg, test=F)
    }
    else if (input$FC_Model == "Fourier_Reg_Sns") {
      checkresiduals(Fourier_Reg_Sns, test=F)
    }
    else if (input$FC_Model == "Fourier_Period") {
      checkresiduals(Fourier_Period, test=F)
    }
    else if (input$FC_Model == "TBATS") {
      checkresiduals(TBATS, test=F)
    }
    else if (input$FC_Model == "MSTS_Sns") {
      checkresiduals(MSTS_Sns, test=F)
    }
    else if (input$FC_Model == "NN") {
      checkresiduals(NN, test=F)
    }
    else if (input$FC_Model == "NN_Sns") {
      checkresiduals(NN_Sns, test=F)
    }
  })
  output$decom = renderPlot(plot(decom_oil))
}
)
```

